'''
----------------------------------------------------------
Shia Ithana Ashari Prayer Times Calculator
Version 4.5
Date: 24-11-2024
----------------------------------------------------------
Inputs: a start year, end year, and latitude/longitude coordinates
Outputs: an .xlsx file of prayer times from 01-Jan-StartYear to 31-Dec-EndYear, and images of the prayer times table for each calendar month    

Uses CSV data generated by the United States Naval Observatory (exact data, no approximate calculations).
- Source: https://aa.usno.navy.mil/data/geocentric

----------------------------------------------------------
IMPORTANT: Angle Values:
1. Fajr Angle:      16° (per Leva Research Institute, Qum)
2. Maghrib Angle:   4° (best guess from praytimes.org)
3. Isha Angle:      14° (per Leva Research Institute, Qum)
4. Midnight:        Calculated as the midpoint of Sunset and Fajr (This is hardcoded)

----------------------------------------------------------

License: GNU GPL v3.0

TERMS OF USE:
Permission is granted to use this code, with or without modification, in any website or application, as long as credit is given to the original work with a link back to https://github.com/GhayurH/Salaah. The use of this code cannot be for monetary profit, except if the website or application hosting the code also displays advertisements, provided that it is not solely dedicated to running this code.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.

PLEASE DO NOT REMOVE THIS COPYRIGHT BLOCK.

---------------------Acknowledgement-------------------------
Code inspired by praytimes.org.
'''

import os
import math
from datetime import datetime
import pandas as pd
from timezonefinder import TimezoneFinder
import pytz
import matplotlib.pyplot as plt
from geopy.geocoders import Nominatim

# Define constants to be used
start_year, end_year   = 2025, 2025
# coordinates          = [43.841668, -79.460900] # JCC
# coordinates          = [43.429516, -80.484115] # Kitchener
# coordinates          = [43.441318, -80.487407] # AZSA
# coordinates          = [lat, long]
coordinates            = [42.298759, -83.035436] # Windsor
elev                   = 0  # elevation, only necessary for high altitudes
input_file_path        = r'C:\Users\Ghayur Haider\Desktop\AZ\Git\Salaah\current version\EqT and D.csv'
output_directory       = r'C:\Users\Ghayur Haider\Desktop\AZ\Git\Salaah\output'
output_filename        = 'Windsor 2025.xlsx'

# Prayer time calculation constants
Fajr_Angle    = 16
Maghrib_Angle = 4
Isha_Angle    = 14

# Set the font family globally
plt.rcParams['font.family'] = 'Calibri'
plt.rcParams['font.size']   = 12

# Pre-process the CSV data and index by date for fast lookup
df = pd.read_csv(input_file_path)
# Combine year, month, and day into a string format 'YYYY-MM-DD'
df['Date'] = (
    df['date_y'].astype(str)
    + '-'
    + df['date_m'].astype(str).str.zfill(2)
    + '-'
    + df['date_d'].astype(str).str.zfill(2)
)
# Convert the combined string column to a datetime object
df['Date'] = pd.to_datetime(df['Date'], format='%Y-%m-%d', errors='coerce')
df.set_index('Date', inplace=True)

# Geopy function to get city name
def get_city_name(lat, lon):
    geolocator = Nominatim(user_agent="prayer_times_calculator")
    location = geolocator.reverse((lat, lon), exactly_one=True)
    if location and 'city' in location.raw['address']:
        return location.raw['address']['city']
    elif location and 'town' in location.raw['address']:
        return location.raw['address']['town']
    elif location and 'village' in location.raw['address']:
        return location.raw['address']['village']
    else:
        return "Unknown Location"


# Function to calculate declination and equation of time from the pre-processed CSV
def calculate_declination_eqt(date_obj):
    if date_obj in df.index:
        filtered_row = df.loc[date_obj]
        declination = filtered_row['D_sign'] * (
            filtered_row['D_deg']
            + (filtered_row['D_min'] / 60)
            + (filtered_row['D_sec'] / 3600)
        )
        EqT = filtered_row['EqT_sign'] * (
            filtered_row['EqT_m'] + (filtered_row['EqT_s'] / 60)
        )
        return declination, EqT
    else:
        raise ValueError(f"No Declination and EqT data found for date: {date_obj}")


# Helper function for prayer time calculations
def T(x, latitude, declination):
    numerator = (
        -math.sin(math.radians(x))
        - math.sin(math.radians(latitude)) * math.sin(math.radians(declination))
    )
    denominator = math.cos(math.radians(latitude)) * math.cos(math.radians(declination))
    cos_T = numerator / denominator
    return math.degrees(math.acos(cos_T)) / 15.0


# Function to convert decimal time to HH:MM:SS format
def decimal_to_hms(decimal_hours):
    hours = int(decimal_hours)
    minutes = int((decimal_hours - hours) * 60)
    seconds = int(((decimal_hours - hours) * 60 - minutes) * 60)
    return f"{hours:02d}:{minutes:02d}:{seconds:02d}"


# Function to calculate prayer times
def calculate_prayer_times(date_obj, latitude, longitude, timezone_offset, elevation):
    declination, EqT = calculate_declination_eqt(date_obj)

    Dhuhr = 12 + timezone_offset - longitude / 15.0 - EqT / 60.0
    sunrise = Dhuhr - T(
        0.833 + (0.0347 * math.sqrt(elevation)), latitude, declination
    )
    sunset = Dhuhr + T(
        0.833 + (0.0347 * math.sqrt(elevation)), latitude, declination
    )

    fajr = Dhuhr - T(Fajr_Angle, latitude, declination)
    isha = Dhuhr + T(Isha_Angle, latitude, declination)

    try:
        num1 = math.sin(
            math.atan2(1, 1 + math.tan(math.radians(abs(latitude - declination))))
        )
        num2 = math.sin(math.radians(latitude)) * math.sin(math.radians(declination))
        deno = math.cos(math.radians(latitude)) * math.cos(math.radians(declination))
        cos_A = (num1 - num2) / deno

        asr_A = math.degrees(math.acos(cos_A)) / 15.0
        Asr = Dhuhr + asr_A
    except ValueError:
        # Handle cases where Asr cannot be calculated
        Asr = None

    maghrib = Dhuhr + T(Maghrib_Angle, latitude, declination)
    midnight = sunset + ((fajr + 24 - sunset) / 2)

    return {
        "Date": date_obj,
        "Fajr": decimal_to_hms(fajr),
        "Sunrise": decimal_to_hms(sunrise),
        "Dhuhr": decimal_to_hms(Dhuhr),
        "Asr": decimal_to_hms(Asr) if Asr else "N/A",
        "Sunset": decimal_to_hms(sunset),
        "Maghrib": decimal_to_hms(maghrib),
        "Isha": decimal_to_hms(isha),
        "Midnight": decimal_to_hms(midnight),
    }


# Function to save prayer times to an Excel file
def save_prayer_times_to_xlsx(prayer_times_list, output_file):
    df = pd.DataFrame(prayer_times_list)
    new_column_order = [
        'Date',
        'Fajr',
        'Sunrise',
        'Dhuhr',
        'Asr',
        'Sunset',
        'Maghrib',
        'Isha',
        'Midnight',
    ]
    df = df[new_column_order]

    df['Date'] = pd.to_datetime(df['Date']) # Convert Date column to datetime format (useful if excel failing to recognize this natively as a date)
    # df['Date'] = pd.to_datetime(df['Date']).dt.date

    df.to_excel(output_file, index=False)


# Batch image generation for prayer times
def save_batch_images(prayer_times_list, output_directory, city_name):
    # Convert the list of prayer times into a DataFrame
    df = pd.DataFrame(prayer_times_list)

    # Group by year and month for batch processing
    df['Date'] = pd.to_datetime(df['Date'], format='%Y-%m-%d')
    df['Year'] = df['Date'].dt.year
    df['Month'] = df['Date'].dt.month_name()

    grouped = df.groupby(['Year', 'Month'])

    # Generate images in batches
    for (year, month), group in grouped:
        table_data = group[
            ['Date', 'Fajr', 'Sunrise', 'Dhuhr', 'Sunset', 'Maghrib', 'Midnight']
        ]

        # Dynamically calculate figure size based on table content
        fig_width = len(table_data.columns) * 0.6
        fig_height = len(table_data) * 0.225  # Adding space for the title and subtitle

        fig, ax = plt.subplots(figsize=(fig_width, fig_height))

        ax.axis('tight')
        ax.axis('off')

        # Explicitly cast to string to avoid FutureWarning
        table_data['Date'] = table_data['Date'].dt.strftime('%b %d')

        table = ax.table(
            cellText=table_data.values,
            colLabels=table_data.columns,
            cellLoc='center',
            loc='center',
        )

        # Adjust column width to fit content
        table.auto_set_column_width(col=list(range(len(table_data.columns))))

        # Style the table (font, color)
        for (i, j), cell in table.get_celld().items():
            # Set vertical alignment to center for all cells
            cell.set_text_props(va='center')  # Vertically center the text

            if i == 0:  # Header row
                cell.set_text_props(weight='bold', fontsize=12)
                cell.set_facecolor('#D9D9D9')  # Light gray for header
            else:
                # Alternate row colors for banding
                if i % 2 == 0:  # Even rows
                    cell.set_facecolor('#D9D9D9')  # Light gray
                else:  # Odd rows
                    cell.set_facecolor('#ffffff')  # White

                # Additional styling for specific columns
                if j == 0:  # Date column
                    cell.set_text_props(weight='bold', color='#000000')  # Black for the date
                elif j in [1, 2]:  # Fajr and Sunrise columns
                    cell.set_text_props(color='#00B24E')  # Green for Fajr and Sunrise
                elif j in [3, 4]:  # Dhuhr and Sunset columns
                    cell.set_text_props(color='#BD5113')  # Brown for Dhuhr and Sunset
                elif j in [5, 6]:  # Maghrib and Midnight columns
                    cell.set_text_props(color='#0170BF')  # Blue for Maghrib and Midnight

        # Set title and subtitle with city name
        plt.suptitle(
            f'{month} {year} Prayer Times', fontsize=16, ha='center', va='center', y=0.98
        )
        plt.title(f'for {city_name}', fontsize=12, ha='center', va='center')

        plt.tight_layout(pad=0.0)

        image_path = os.path.join(output_directory, f'{city_name} - {month} {year}.png')
        plt.savefig(image_path, bbox_inches='tight', dpi=300)
        plt.close(fig)


# Main loop to calculate prayer times for the year range
def main():
    all_prayer_times = []
    lat, lon = coordinates
    city_name = get_city_name(lat, lon)  # Get the city name based on latitude and longitude

    # Get timezone information
    tf = TimezoneFinder()
    timezone_str = tf.timezone_at(lng=lon, lat=lat)
    if timezone_str is None:
        print("Timezone could not be determined.")
        return
    tz = pytz.timezone(timezone_str)

    date_range = pd.date_range(start=f'{start_year}-01-01', end=f'{end_year}-12-31')

    for date_obj in date_range:
        try:
            # Localize at noon to correctly capture DST transitions
            localized_date = tz.localize(
                datetime(date_obj.year, date_obj.month, date_obj.day, 12, 0, 0)
            )
            timezone_offset = localized_date.utcoffset().total_seconds() / 3600.0

            prayer_times = calculate_prayer_times(
                date_obj, lat, lon, timezone_offset, elev
            )
            all_prayer_times.append(prayer_times)
        except Exception as e:
            print(f"Skipping date {date_obj}: {e}")

    # Ensure the output directory exists
    if not os.path.exists(output_directory):
        os.makedirs(output_directory)

    # Ensure the images subdirectory exists
    images_subdir = os.path.join(output_directory, 'images')
    if not os.path.exists(images_subdir):
        os.makedirs(images_subdir)

    # Prepare the output paths
    output_xlsx_path = os.path.join(output_directory, output_filename)

    # Save prayer times to Excel and generate images
    save_prayer_times_to_xlsx(all_prayer_times, output_xlsx_path)
    save_batch_images(all_prayer_times, images_subdir, city_name)

    print(f'Prayer times saved to {output_xlsx_path}')
    print(f'Monthly images saved to {images_subdir}')


# Execute the main function
if __name__ == '__main__':
    main()