'''
----------------------------------------------------------
Shia Ithana Ashari Prayer Times Calculator
Version 4.4
Date: 24-11-2024
----------------------------------------------------------
Inputs: a start year, end year, and latitude/longitude coordinates
Outputs: an .xlsx file of prayer times from 01-Jan-StartYear to 31-Dec-EndYear, and images of the prayer times table for each calendar month    

Uses CSV data generated by the United States Naval Observatory (exact data, no approximate calculations).
- Source: https://aa.usno.navy.mil/data/geocentric

----------------------------------------------------------
IMPORTANT: Angle Values:
1. Fajr Angle:      16° (per Leva Research Institute, Qum)
2. Maghrib Angle:   4° (best guess from praytimes.org)
3. Isha Angle:      14° (per Leva Research Institute, Qum)
4. Midnight:        Calculated as the midpoint of Sunset and Fajr (This is hardcoded)

----------------------------------------------------------

License: GNU GPL v3.0

TERMS OF USE:
Permission is granted to use this code, with or without modification, in any website or application, as long as credit is given to the original work with a link back to https://github.com/GhayurH/Salaah. The use of this code cannot be for monetary profit, except if the website or application hosting the code also displays advertisements, provided that it is not solely dedicated to running this code.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.

PLEASE DO NOT REMOVE THIS COPYRIGHT BLOCK.

---------------------Acknowledgement-------------------------
Code inspired by praytimes.org.
'''

import os
import math
from datetime import datetime, timedelta
import pandas as pd
from timezonefinder import TimezoneFinder
import pytz
import matplotlib.pyplot as plt
from geopy.geocoders import Nominatim

# Define constants to be used
start_year, end_year   = 2025, 2025
# coordinates          = [43.841668, -79.460900] # JCC
# coordinates          = [43.429516, -80.484115] # Kitchener
# coordinates          = [43.441318, -80.487407] # AZSA
# coordinates          = [lat, long]
coordinates            = [42.298759, -83.035436] # Windsor
elev                   = 0  # elevation, only necessary for high altitudes
input_file_path        = r'C:\Users\Ghayur Haider\Desktop\AZ\Git\Salaah\current version\EqT and D.csv'
output_directory       = r'C:\Users\Ghayur Haider\Desktop\AZ\Git\Salaah\output'
output_filename        = 'Windsor 2024.xlsx'

# Prayer time calculation constants
Fajr_Angle    = 16
Maghrib_Angle = 4
Isha_Angle    = 14

# Set the font family globally
plt.rcParams['font.family'] = 'Calibri'
plt.rcParams['font.size']   = 12

# Pre-process the CSV data and index by date for fast lookup
df = pd.read_csv(input_file_path)
# Combine year, month, and day into a string format 'YYYY-MM-DD'
df['Date'] = df['date_y'].astype(str) + '-' + df['date_m'].astype(str).str.zfill(2) + '-' + df['date_d'].astype(str).str.zfill(2)
# Convert the combined string column to a datetime object
df['Date'] = pd.to_datetime(df['Date'], format='%Y-%m-%d', errors='coerce')
df.set_index('Date', inplace=True)

# Geopy function to get city name
def get_city_name(lat, lon):
    geolocator = Nominatim(user_agent="cityfind")
    location = geolocator.reverse((lat, lon), exactly_one=True)
    if location and 'city' in location.raw['address']:
        return location.raw['address']['city']
    elif location and 'town' in location.raw['address']:
        return location.raw['address']['town']
    elif location and 'village' in location.raw['address']:
        return location.raw['address']['village']
    else:
        return "Unknown Location"

# Function to get timezone and DST information dynamically
def get_timezone_and_dst_info(lat, lon, start_year=None, end_year=None):
    tf = TimezoneFinder()
    timezone_str = tf.timezone_at(lng=lon, lat=lat)

    if timezone_str is None:
        return "Timezone could not be determined."

    timezone = pytz.timezone(timezone_str)
    non_dst_time = timezone.localize(datetime(datetime.now().year, 1, 1))
    utc_offset = non_dst_time.utcoffset().total_seconds() / 3600

    min_year = 1900
    max_year = 2100
    valid_transitions = [t for t in timezone._utc_transition_times if min_year <= t.year <= max_year]

    is_loc_dst = any(timezone.localize(transition).dst() != timedelta(0) for transition in valid_transitions)

    dst_start_dates = []
    dst_end_dates = []
    if start_year and end_year:
        for year in range(start_year, end_year + 1):
            jan_1 = datetime(year, 1, 1, tzinfo=pytz.utc)
            dec_31 = datetime(year, 12, 31, tzinfo=pytz.utc)

            for transition_time in valid_transitions:
                transition_aware = pytz.utc.localize(transition_time)
                if jan_1 <= transition_aware <= dec_31:
                    if timezone.localize(transition_time).dst():
                        dst_start_dates.append(transition_time.date())
                    else:
                        dst_end_dates.append(transition_time.date())

    return {
        "timezone_utc_offset": utc_offset,
        "is_loc_dst": is_loc_dst,
        "dst_start_dates": dst_start_dates if start_year and end_year else None,
        "dst_end_dates": dst_end_dates if start_year and end_year else None
    }


# Function to calculate declination and equation of time from the pre-processed CSV
def calculate_declination_eqt(date_obj):
    if date_obj in df.index:
        filtered_row = df.loc[date_obj]
        declination = filtered_row['D_sign'] * (filtered_row['D_deg'] + (filtered_row['D_min'] / 60) + (filtered_row['D_sec'] / 3600))
        EqT = filtered_row['EqT_sign'] * (filtered_row['EqT_m'] + (filtered_row['EqT_s'] / 60))
        return declination, EqT
    else:
        raise ValueError(f"No Declination and EqT data found for date: {date_obj}")


# Helper function for prayer time calculations
def T(x, latitude, declination):
    numerator = (-math.sin(math.radians(x)) - math.sin(math.radians(latitude)) * math.sin(math.radians(declination)))
    denominator = (math.cos(math.radians(latitude)) * math.cos(math.radians(declination)))
    cos_T = numerator / denominator
    return math.degrees(math.acos(cos_T)) / 15.0


# Function to convert decimal time to HH:MM:SS format
def decimal_to_hms(decimal_hours):
    hours = int(decimal_hours)
    minutes = int((decimal_hours - hours) * 60)
    seconds = int(((decimal_hours - hours) * 60 - minutes) * 60)
    return f"{hours:02d}:{minutes:02d}:{seconds:02d}"


# Function to calculate prayer times
def calculate_prayer_times(date_obj, latitude, longitude, timezone, elevation):
    declination, EqT = calculate_declination_eqt(date_obj)

    Dhuhr = 12 + timezone - longitude / 15.0 - EqT / 60.0
    sunrise = Dhuhr - T(0.833 + (0.0347 * math.sqrt(elevation)), latitude, declination)
    sunset = Dhuhr + T(0.833 + (0.0347 * math.sqrt(elevation)), latitude, declination)

    fajr = Dhuhr - T(Fajr_Angle, latitude, declination)
    isha = Dhuhr + T(Isha_Angle, latitude, declination)

    num1 = math.sin(math.atan2(1, 1 + math.tan(math.radians(abs(latitude - declination)))))
    num2 = math.sin(math.radians(latitude)) * math.sin(math.radians(declination))
    deno = (math.cos(math.radians(latitude)) * math.cos(math.radians(declination)))
    cos_A = (num1 - num2) / deno
    asr_A = math.degrees(math.acos(cos_A)) / 15.0
    Asr = Dhuhr + asr_A

    maghrib = Dhuhr + T(Maghrib_Angle, latitude, declination)
    midnight = sunset + ((fajr + 24 - sunset) / 2)

    return {
        "Date": date_obj,  # Store as datetime object
        "Fajr": decimal_to_hms(fajr),
        "Sunrise": decimal_to_hms(sunrise),
        "Dhuhr": decimal_to_hms(Dhuhr),
        "Asr": decimal_to_hms(Asr),
        "Sunset": decimal_to_hms(sunset),
        "Maghrib": decimal_to_hms(maghrib),
        "Isha": decimal_to_hms(isha),
        "Midnight": decimal_to_hms(midnight)
    }


# Function to save prayer times to an Excel file
def save_prayer_times_to_xlsx(prayer_times_list, output_file):
    df = pd.DataFrame(prayer_times_list)
    new_column_order = ['Date', 'Fajr', 'Sunrise', 'Dhuhr', 'Asr', 'Sunset', 'Maghrib', 'Isha', 'Midnight']
    df = df[new_column_order]

    df['Date'] = pd.to_datetime(df['Date']) # Convert Date column to datetime format (useful if excel failing to recognize this natively as a date)
    # df['Date'] = pd.to_datetime(df['Date']).dt.date

    df.to_excel(output_file, index=False)


# Batch image generation for prayer times
def save_batch_images(prayer_times_list, output_directory, city_name):
    # Convert the list of prayer times into a DataFrame
    df = pd.DataFrame(prayer_times_list)

    # Group by year and month for batch processing
    df['Date'] = pd.to_datetime(df['Date'], format='%Y-%m-%d')
    df['Year'] = df['Date'].dt.year
    df['Month'] = df['Date'].dt.month_name()

    grouped = df.groupby(['Year', 'Month'])

    # Generate images in batches
    for (year, month), group in grouped:
        table_data = group[['Date', 'Fajr', 'Sunrise', 'Dhuhr', 'Sunset', 'Maghrib', 'Midnight']]

        # Dynamically calculate figure size based on table content
        fig_width = len(table_data.columns) * .6
        fig_height = len(table_data) * 0.225  # Adding space for the title and subtitle

        fig, ax = plt.subplots(figsize=(fig_width, fig_height))

        ax.axis('tight')
        ax.axis('off')

        # Explicitly cast to string to avoid FutureWarning
        table_data['Date'] = table_data['Date'].dt.strftime('%b %d')

        table = ax.table(cellText=table_data.values,
                         colLabels=table_data.columns,
                         cellLoc='center',
                         loc='center')

        # Adjust column width to fit content
        table.auto_set_column_width([0, 1, 2, 3, 4, 5, 6])

        # Style the table (font, color)
        for (i, j), cell in table.get_celld().items():
            # Set vertical alignment to center for all cells
            cell.set_text_props(va='center')  # Vertically center the text

            if i == 0:  # Header row
                cell.set_text_props(weight='bold', fontsize=12)
                cell.set_facecolor('#D9D9D9')  # Light gray for header
            else:
                # Alternate row colors for banding
                if i % 2 == 0:  # Even rows
                    cell.set_facecolor('#D9D9D9')  # Light gray
                else:  # Odd rows
                    cell.set_facecolor('#ffffff')  # White

                # Additional styling for specific columns
                if j == 0:  # Date column
                    cell.set_text_props(weight='bold', color='#000000')  # Black for the date
                elif j in [1, 2]:  # Fajr and Sunrise columns
                    cell.set_text_props(color='#00B24E')  # Green for Fajr and Sunrise
                elif j in [3, 4]:  # Dhuhr and Sunset columns
                    cell.set_text_props(color='#BD5113')  # Brown for Dhuhr and Sunset
                elif j in [5, 6]:  # Maghrib and Midnight columns
                    cell.set_text_props(color='#0170BF')  # Blue for Maghrib and Midnight

        # Set title and subtitle with city name
        plt.suptitle(f'{month} {year} Prayer Times', fontsize=16, ha='center', va='center', y=0.98)
        plt.title(f'for {city_name}', fontsize=12, ha='center', va='center')

        plt.tight_layout(pad=0.0)

        image_path = f'{output_directory}/{city_name} - {month} {year}.png'
        plt.savefig(image_path, bbox_inches='tight', dpi=300)
        plt.close(fig)



# Main loop to calculate prayer times for the year range
def main():
    all_prayer_times = []
    lat, lon = coordinates
    city_name = get_city_name(lat, lon)  # Get the city name based on latitude and longitude
    tz_info = get_timezone_and_dst_info(lat, lon, start_year, end_year)

    base_timezone = tz_info['timezone_utc_offset']

    date_range = pd.date_range(start=f'{start_year}-01-01', end=f'{end_year}-12-31')

    for date_obj in date_range:
        try:
            # Check if the current date is within the DST period
            is_dst = any(
                start <= date_obj.date() < end
                for start, end in zip(tz_info['dst_start_dates'], tz_info['dst_end_dates'])
            ) if tz_info['dst_start_dates'] and tz_info['dst_end_dates'] else False
            timezone = base_timezone + 1 if is_dst else base_timezone

            prayer_times = calculate_prayer_times(date_obj, lat, lon, timezone, elev)
            all_prayer_times.append(prayer_times)
        except ValueError as e:
            print(f"Skipping invalid date {date_obj}: {e}")

    # Ensure the output directory exists
    if not os.path.exists(output_directory):
        os.makedirs(output_directory)

    # Ensure the images subdirectory exists
    images_subdir = os.path.join(output_directory, 'images')
    if not os.path.exists(images_subdir):
        os.makedirs(images_subdir)

    # Prepare the output paths
    output_xlsx_path = os.path.join(output_directory, output_filename)

    # Save prayer times to Excel and generate images
    save_prayer_times_to_xlsx(all_prayer_times, output_xlsx_path)
    save_batch_images(all_prayer_times, images_subdir, city_name)

    print(f'Prayer times saved to {output_xlsx_path}')
    print(f'Monthly images saved to {images_subdir}')


# Execute the main function
if __name__ == '__main__':
    main()